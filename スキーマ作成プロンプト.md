# Copilotプロンプト: SQLAlchemy + FastAPI + Pydantic v2 でテーブル名とデータを分離したフラットなリスト構造

## 目標
SQLAlchemyで定義された複数のテーブル（3階層のリレーションを持つ）を、FastAPIとPydantic v2を使って以下の形式のJSONとして返す:

```json
{
  "tables": [
    {
      "table_name": "テーブル名1",
      "data": { /* テーブル1のデータ */ }
    },
    {
      "table_name": "テーブル名2",
      "data": { /* テーブル2のデータ */ }
    },
    {
      "table_name": "テーブル名3",
      "data": { /* テーブル3のデータ */ }
    }
  ]
}
```

## コード生成プロンプト

```python
# FastAPIとSQLAlchemy、Pydantic v2を使用して、複数のテーブルデータをフラットなリスト形式で返すAPIエンドポイントを実装します
# テーブル構造はUser、Post、Commentの3階層のリレーションを持ちます
# レスポンスは { "tables": [ {"table_name": "テーブル名", "data": {...フィールド}} ] } 形式とします
# Pydantic v2の機能を活用してください

from typing import List, Dict, Any, Optional
from datetime import datetime
from pydantic import BaseModel, Field
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship, Session, DeclarativeBase, Mapped, mapped_column
from fastapi import FastAPI, Depends, HTTPException

# SQLAlchemyのベースクラス定義
class Base(DeclarativeBase):
    pass

# SQLAlchemyモデル定義 - 3階層のリレーション
class User(Base):
    __tablename__ = "users"
    
    id = mapped_column(Integer, primary_key=True)
    username = mapped_column(String, unique=True)
    email = mapped_column(String)
    
    # リレーション
    posts: Mapped[List["Post"]] = relationship("Post", back_populates="user")

class Post(Base):
    __tablename__ = "posts"
    
    id = mapped_column(Integer, primary_key=True)
    title = mapped_column(String)
    content = mapped_column(String)
    user_id = mapped_column(Integer, ForeignKey("users.id"))
    
    # リレーション
    user: Mapped["User"] = relationship("User", back_populates="posts")
    comments: Mapped[List["Comment"]] = relationship("Comment", back_populates="post")

class Comment(Base):
    __tablename__ = "comments"
    
    id = mapped_column(Integer, primary_key=True)
    content = mapped_column(String)
    post_id = mapped_column(Integer, ForeignKey("posts.id"))
    
    # リレーション
    post: Mapped["Post"] = relationship("Post", back_populates="comments")

# Pydantic v2モデルを定義し、テーブル名とデータを分離した構造を実現してください
# 出力形式: { "tables": [ {"table_name": "テーブル名", "data": {...フィールド}} ] }

# TODO: ここにPydantic v2モデルを定義

# FastAPIアプリケーション
app = FastAPI()

# データベース設定
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL)
Base.metadata.create_all(bind=engine)

def get_db():
    db = Session(engine)
    try:
        yield db
    finally:
        db.close()

# TODO: テーブル名とデータを分離した構造でデータを返すエンドポイントを実装
# フラットなリスト形式で返すようにしてください
```

## 補足指示
以下の要件も満たすようにしてください:

1. Pydantic v2の最新機能（model_validate, model_dump, Field, ConfigDict等）を使用
2. 日時フィールドはISO形式に変換する
3. ORM関連のデータ変換は効率的に行う
4. FastAPIのレスポンスモデルとして適切に定義する
5. エンドポイントは `/users/{user_id}/flat` の形式で、指定したユーザーとその関連データを全て返す
